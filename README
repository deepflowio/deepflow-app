#### 获取关联flow

-  根据tcp_seq获取flow：1.network span 2.service间调用的system span
  - type=request,使用req_tcp_seq关联查询，相同req_tcp_seq的flow会被关联

  ```
  req_tcp_seq={flow.req_tcp_seq}
  ```

  - type=response,使用resp_tcp_seq关联查询，相同resp_tcp_seq的flow会被关联

  ```
  resp_tcp_seq={flow.resp_tcp_seq}
  ```

  - type=session: req_tcp_seq or resp_tcp_seq

  ```
  (req_tcp_seq={flow.req_tcp_seq} or resp_tcp_seq={flow.resp_tcp_seq})
  ```

  - 额外条件
    - resp_tcp_seq!=0 OR req_tcp_seq!=0
    - span_id必须相同
    - x_request_id必须相同

- 根据syscalltraceid获取flow：1.service内部的system span

  - syscall_trace_id_request以及syscall_trace_id_request只要不为0则都会被关联查询

  ```
  syscall_trace_id_request={flow.syscall_trace_id_request} OR syscall_trace_id_response={flow.syscall_trace_id_request} OR 
  syscall_trace_id_request={flow.syscall_trace_id_response} OR syscall_trace_id_response={flow.syscall_trace_id_response}
  ```

  - 额外条件
    - vtap_id必须相同

- 获取app span
 
  - 根据parent_span_id以及span_id关联查询

  ```
  parent_span_id={flow.span_id} OR span_id={flow.span_id}
  span_id={flow.parent_span_id} OR parent_span_id={flow.parent_span_id}
  ```

- x_request_id

  ```
  x_request_id={flow.x_request_id}
  ```

- trace_id

  ```
  trace_id={trace_id}
  ```

- sql,将上述所有条件用OR进行拼接，查询所有符合条件的flow，然后进行细粒度的筛选：
  
  - network span：
      - 时间范围差距不能超过配置的网络最大时延`network_delay_us`

      ```
      abs(self.start_time_us - flow.start_time_us) <= self.network_delay_us
      abs(self.end_time_us - flow.end_time_us) <= self.network_delay_us
      ```

- 返回结果中对关联关系的描述：
  
  - 字段：related_ids
  - 值：[flowindex-关联type-数据库id]，例：
  ```
  ["16-traceid-7148686813239271301", "1-app-7148686813239271297"]
  ```
  - 关联type：
    1. network，表示是通过tcp_seq追踪出的数据
    2. syscall，表示是通过syscalltraceid追踪出的数据
    3. app，表示是通过span_id以及parent_span_id追踪出的数据
    4. traceid，表示是通过trace_id追踪出的数据
    5. xrequestid，表示是通过x_request_id追踪出的数据

#### merge flow

  - 以下flow不进行合并
    1. type == session && tap_side != sysspan，会话类型的非系统span
    2. tap_side != sysspan时，每条flow的_id最多只有一来一回两条， 大于等于两条
    3. ('vtap_id', 'tap_port', 'tap_port_type', 'l7_protocol', 'request_id', 'tap_side', 'flow_id')不同
    4. request的start_time > response的start_time
    5. sysspan的flow，request_flow['syscall_cap_seq_0'] + 1 != response_flow['syscall_cap_seq_1']

  - 合并字段,被合并的flow会将原flow中缺少的字段补充进去
    - flow['type'] == 0，按以下字段合并
  
    ```
    [
      'l7_protocol', 'protocol', 'version', 'request_type', 'request_domain',
      'request_resource', 'request_id'
    ]
    ```
  
    - flow['type'] == 1，按以下字段合并
  
    ```
    [
      'response_status', 'response_code', 'response_exception',
      'response_result', 'http_proxy_client'
    ]
    ```
  
    - 其他
  
    ``` 
    [ 
      'l7_protocol', 'protocol', 'version', 'request_type', 'request_domain',
      'request_resource', 'request_id', 'response_status', 'response_code',
      'response_exception', 'response_result', 'http_proxy_client', 'trace_id',
      'span_id', 'x_request_id'
    ]
    ```
  
    - request 和 response合并时，flow[type] 会改成2（session）

    - sysspan首次merge会出现merge失败，需要将flow倒序，再进行第二次merge

#### 排序逻辑



##### 构建service
  - 进程span
    - 基于每个tap_side为s-p的flow构建一个service
    - 将每个tap_side为c-p的flow添加进所属的service中，判断所属service的逻辑为vtap_id及process_id与service相同，并且s-p的时间范围需要覆盖c-p，有多个service符合条件的情况下选择start_time最近的。
  - 网络span添加进service
    - 与service比较以下字段是否相等。
    ```
    [
      'l7_protocol', 'protocol', 'version', 'request_type', 'request_domain',
      'request_resource', 'request_id', 'response_status', 'response_code',
      'response_exception', 'response_result', 'http_proxy_client', 'trace_id',
      'span_id', 'x_request_id'
    ]
    ```
    - 在service的进程span中寻找到含有相同的req_tcp_seq或者resp_tcp_seq的进程span，并且start_time时间差在参数network_delay_us之内，将网络span的flow并挂在该进程span下

  - 应用span添加进service
    - 应用span的span_id与系统span_id相同。如果系统span的tap_side是c-p，则将该应用span添加进service
    - 应用span的parent_id与系统span_id相同时。如果系统span的tap_side是s-p并且不存在和s-p相同的c-p时，将该应用span添加进service
    - 两条应用span的span_id有关联并且service_name相同时，将其中一条还为添加进service的flow添加进另一条flow所属的service中


##### 设置parent


- 网络span
  1. 存在tcp_seq相同的flow，非local和rest按照以下优先级确认parent，local和rest就近（比较采集器）排到其他位置（tcp_seq相同）附近（按时间排）
  ```
  [c, c-nd, c-hv, c-gw-hv, c-gw, s-gw, s-gw-hv, s-hv, s-nd, s]
  ```
  2. 存在span_id相同的应用span，将该网络span的parent设置为该span_id相同的应用span

- 应用span
  1. 若存在parent_span_id，且存在tap_side=s的flow的span_id等于该parent_span_id,则将该应用span的parent设置为该flow
  2. 若存在parent_span_id，且span_id等于该parent_span_id的flow存在span_id相同的网络span，则将该应用span的parent设置为该网络span
  3. 若存在parent_span_id, 将该应用span的parent设置为span_id等于该parent_span_id的flow
  4. 若有所属service，将该应用span的parent设置为该service的s-p的flow

- 系统span，tap_side=c
  1. 存在span_id相同的应用span，将该系统span的parent设置为该span_id相同的应用span
  2. 所属service中存在应用span，将该系统span的arent设置为service中最后一条应用span
  3. 存在syscalltraceid相同且tap_side=s的系统span，该系统span的parent设置为该flow(syscalltraceid相同且tap_side=s)

- 系统span，tap_side=s
  1. 存在span_id相同的应用span，将该系统span的parent设置为该span_id相同的应用span
  2. 存在span_id相同且存在parent_span_id的flow，将该系统span的parent设置为span_id等于该parent_span_id的flow
  